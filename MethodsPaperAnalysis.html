<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Matt Cannon" />
  <title>MethodsPaperAnalysis</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- jQuery -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>
  
  <!-- bootstrap -->
  <!--<link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet"  id="style">-->
  <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
  
  <!-- highlight.js -->
  <!--<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/default.min.css" rel="stylesheet" id="code-style">-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
  <script>
  hljs.LANGUAGES.r=function(a){var b="([a-zA-Z]|\\.[a-zA-Z.])[a-zA-Z0-9._]*";return{c:[a.HCM,{b:b,l:b,k:{keyword:"function if in break next repeat else for return switch while try tryCatch|10 stop warning require library attach detach source setMethod setGeneric setGroupGeneric setClass ...|10",literal:"NULL NA TRUE FALSE T F Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10"},r:0},{cN:"number",b:"0[xX][0-9a-fA-F]+[Li]?\\b",r:0},{cN:"number",b:"\\d+(?:[eE][+\\-]?\\d*)?L\\b",r:0},{cN:"number",b:"\\d+\\.(?!\\d)(?:i\\b)?",r:0},{cN:"number",b:"\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[a.BE],r:0},{cN:"string",b:"'",e:"'",c:[a.BE],r:0}]}}(hljs); </script>
  <!--<script type="text/javascript", src="https://yandex.st/highlightjs/7.3/languages/r.min.js"></script>-->
  
  <!-- Manific Popup -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/0.8.9/jquery.magnific-popup.min.js"></script>
  
  <script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script defer="defer">
  // Function to generate the dynamic table of contents
  jQuery.fn.generate_TOC = function () {
    var base = $(this[0]);
  
    var selectors = ['h1', 'h2', 'h3', 'h4'];
  
    var last_ptr = [{}, {}, {}, {}];
  
    var anchors = {};
  
    generate_anchor = function (text) {
      var test = text.replace(/\W/g, '_');
  
      while(test in anchors){
        //if no suffix, add one
        if(test.match(/_\d+$/) === null){
          test = test + "_2";
        }
        //else generate unique id for duplicates by adding one to the suffix
        else {
          test = test.replace(/_(\d+)$/, function(match, number){ var num=+number+1; return("_" + num) });
        }
      }
      anchors[test]=1;
      return(test);
    }
  
    $(selectors.join(',')).filter(function(index) { return $(this).parent().attr("id") != 'header'; }).each(function () {
  
      var heading = $(this);
      var idx = selectors.indexOf(heading.prop('tagName').toLowerCase());
      var itr = 0;
  
      while (itr <= idx) {
        if (jQuery.isEmptyObject(last_ptr[itr])) {
          last_ptr[itr] = $('<ul>').addClass('nav');
          if (itr === 0) {
            base.append(last_ptr[itr])
          } else {
            if(last_ptr[itr-1].children('li').length === 0){
              last_ptr[itr-1].append(last_ptr[itr]);
            }
            else {
              last_ptr[itr - 1].children('li').last().append(last_ptr[itr]);
            }
          }
        }
        itr++;
      }
      var anchor = generate_anchor(heading.text());
      heading.attr('id', anchor);
      var a = $('<a>')
      .text(heading.text())
      .attr('href', '#' + anchor);
  
    var li = $('<li>')
      .append(a);
  
    last_ptr[idx].append(li);
    for (i = idx + 1; i < last_ptr.length; i++) {
      last_ptr[i] = {};
    }
    });
  }
  /* run scripts when document is ready */
  $(function() {
    "use strict";
  
    var $window = $(window);
    var $body = $(document.body);
  
    /* size of thumbnails */
  
    var hidden_types = ['source']
    var output_types = ['output', 'message', 'warning', 'error']
  
    /* style tables */
    $('table').addClass('table table-striped table-bordered table-hover table-condensed');
  
    $('pre code').each(function(i, e) {
      hljs.highlightBlock(e);
    });
  
    /* Magnific Popup */
    $(".thumbnail").each(function(){
      $(this).magnificPopup({
        disableOn: 768,
        closeOnContentClick: true,
  
        type: 'image',
        items: {
          src: $(this).find('img').attr('src'),
        }
      });
    });
  
    function toggle_block(obj, show) {
      var span = obj.find('span');
      if(show === true){
        span.removeClass('glyphicon-chevron-up').addClass('glyphicon-chevron-down');
        obj.next('pre').slideDown();
      }
      else {
        span.removeClass('glyphicon-chevron-down').addClass('glyphicon-chevron-up');
        obj.next('pre').slideUp();
      }
    }
  
    function toggle_thumbnails(imgs, show){
      if(show === true){
        imgs.parents().show()
        imgs.slideDown();
      }
      else {
        imgs.slideUp(400, function(){ $(this).parent().hide(); });
      }
    }
  
    function global_toggle(obj){
      var type = obj.attr('type');
      var show = !obj.parent('li').hasClass('active');
      if(show === true){
        obj.parent('li').addClass('active');
      }
      else{
        obj.parent('li').removeClass('active');
      }
      if(type == 'figure'){
        toggle_thumbnails($('.thumbnail img'), show);
      }
      else {
        $('.toggle.' + type).each(function() { toggle_block($(this), show); });
      }
    }
  
    /* onclick toggle next code block */
    $('.toggle').click(function() {
      var span = $(this).find('span');
      toggle_block($(this), !span.hasClass('glyphicon-chevron-down'));
      return false
    })
  
    // global toggles
    $('.toggle-global').click(function(){
      var type = $(this).attr('type');
      if(type === 'all-source'){
          $('li a.source').each(function() {
            global_toggle($(this));
          });
        }
      else if(type === 'all-output'){
        $.each(output_types, function(i, val){
          console.log(val);
          global_toggle($('li a.' + val));
        });
      }
      else {
        console.log($(this));
        global_toggle($(this));
      }
      return false;
    });
    /* table of contents */
    if($(['h1', 'h2', 'h3', 'h4'].join(',')).length > 0){
      $('body > #wrap > .container > .row').append('<div class="col-md-2"><div id="toc" class="well sidebar sidenav affix hidden-print"/></div>');
      $('#toc').generate_TOC();
    }
  
    $.each(hidden_types, function(i, type) {
      $('li[type=' + type + ']').each(function(){ global_toggle($(this)); });
    });
  
    /* remove paragraphs with no content */
    $('p:empty').remove();
  
    $body.scrollspy({
      target: '.sidebar',
    });
  
    /* theme switch */
    $('.theme-switch').click(function(){
      var css = $('link[title=' + $(this).attr('title') + ']');
      $('#theme[rel=stylesheet]').attr('href', css.attr('href'));
      $('.theme-switch').closest('li').removeClass('active');
      $(this).closest('li').addClass('active');
      return false;
    });
    /* code style switch */ //TODO use same function for both of these?
    $('.highlight-switch').click(function(){
      var css = $('link[title="' + $(this).attr('title') + '"]');
      $('#highlight[rel=stylesheet]').attr('href', css.attr('href'));
      $('.highlight-switch').closest('li').removeClass('active');
      $(this).closest('li').addClass('active');
      return false;
    });
  
    //TODO refresh on show/hide
    $window.on('load', function () {
      $body.scrollspy('refresh');
    })
  
  });
  
  </script>
  <style>
  /* Knitr_bootstrap styles */
  #header {
    display: none !important;
    visibility: hidden !important;
  }
  #wrap .container-fluid {
    padding: 0;
    overflow: hidden;
  }
  .toggle{
    text-transform: capitalize;
  }
  
  .toggle-global{
    text-transform: capitalize;
  }
  
  /* Sticky footer styles */
  * {
    margin:0;
  }
  html,
  body {
      height: 100%;
      padding:0 !important;
      /* The html and body elements cannot have any padding or margin. */
      /*overflow-x: hidden;*/
  }
  
  /* Wrapper for page content to push down footer */
  #wrap {
      min-height: 100%;
      height: auto !important;
      height: 100%;
      /* Negative indent footer by it's height */
      margin: 0 auto -120px;
  }
  
  /* Set the fixed height of the footer here */
  #push,
  #footer {
      height: 120px;
  }
  
  #footer {
    text-align: center;
  }
  
  /* Top level subheader elements.  These are the first nested items underneath a header element. */
  .header li {
    font-size: 20px;
  }
  
  /* Makes the font smaller for all subheader elements. */
  .sub-header li {
      font-size: 12px;
  }
  
  button.thumbnails {
    margin-left:0px;
  }
  
  /*
   * Side navigation
   *
   * Scrollspy and affixed enhanced navigation to highlight sections and secondary
   * sections of docs content.
   */
  
  /* By default it's not affixed in mobile views, so undo that */
  .sidebar.affix {
    position: static;
  }
  
  /* First level of nav */
  .sidenav {
    margin-top: 30px;
    margin-bottom: 30px;
    padding-top:    10px;
    padding-bottom: 10px;
    border-radius: 5px;
  }
  
  /* All levels of nav */
  .sidebar .nav > li > a {
    display: block;
    padding: 5px 20px;
  }
  .sidebar .nav > li > a:hover,
  .sidebar .nav > li > a:focus {
    text-decoration: none;
    border-right: 1px solid;
  }
  .sidebar .nav > .active > a,
  .sidebar .nav > .active:hover > a,
  .sidebar .nav > .active:focus > a {
    font-weight: bold;
    background-color: transparent;
    border-right: 1px solid;
  }
  
  /* Nav: second level (shown on .active) */
  .sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    margin-bottom: 8px;
  }
  .sidebar .nav .nav > li > a {
    padding-top:    3px;
    padding-bottom: 3px;
    padding-left: 30px;
    font-size: 90%;
  }
  
  .sidebar .nav .nav .nav > li > a {
    padding-left: 40px;
  }
  .sidebar .nav .nav .nav .nav > li > a {
    padding-left: 50px;
  }
  
  /* Show and affix the side nav when space allows it */
  @media screen and (min-width: 992px) {
    .sidebar .nav > .active > ul {
      display: block;
    }
    /* Widen the fixed sidebar */
    .sidebar.affix,
    .sidebar.affix-bottom {
      width: 213px;
    }
    .sidebar.affix-top,
    .sidebar.affix {
      position: fixed; /* Undo the static from mobile first approach */
      top: 30px;
    }
    .sidebar.affix-bottom {
      position: absolute; /* Undo the static from mobile first approach */
    }
    .sidebar.affix-bottom .sidenav,
    .sidebar.affix .sidenav {
      margin-top: 0;
      margin-bottom: 0;
    }
  }
  @media screen and (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .sidebar.affix-bottom,
    .sidebar.affix {
      width: 263px;
    }
  }
  
  #toc {
    padding: 10px 0px;
    margin:0;
    border:0;
  }
  
  
  .panel pre {
    margin: 0;
    padding: 0;
    border: 0;
  }
  button + pre {
    margin: 0;
    padding: 0;
  }
  pre code {
    border-radius: 0;
  }
  /* Magnific Popup CSS */
  .mfp-bg {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1042;
    overflow: hidden;
    position: fixed;
    background: #0b0b0b;
    opacity: 0.8;
    filter: alpha(opacity=80); }
  
  .mfp-wrap {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1043;
    position: fixed;
    outline: none !important;
    -webkit-backface-visibility: hidden; }
  
  .mfp-container {
    text-align: center;
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
    padding: 0 8px;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box; }
  
  .mfp-container:before {
    content: '';
    display: inline-block;
    height: 100%;
    vertical-align: middle; }
  
  .mfp-align-top .mfp-container:before {
    display: none; }
  
  .mfp-content {
    position: relative;
    display: inline-block;
    vertical-align: middle;
    margin: 0 auto;
    text-align: left;
    z-index: 1045; }
  
  .mfp-inline-holder .mfp-content,
  .mfp-ajax-holder .mfp-content {
    width: 100%;
    cursor: auto; }
  
  .mfp-ajax-cur {
    cursor: progress; }
  
  .mfp-zoom-out-cur,
  .mfp-zoom-out-cur .mfp-image-holder .mfp-close {
    cursor: -moz-zoom-out;
    cursor: -webkit-zoom-out;
    cursor: zoom-out; }
  
  .mfp-zoom {
    cursor: pointer;
    cursor: -webkit-zoom-in;
    cursor: -moz-zoom-in;
    cursor: zoom-in; }
  
  .mfp-auto-cursor .mfp-content {
    cursor: auto; }
  
  .mfp-close,
  .mfp-arrow,
  .mfp-preloader,
  .mfp-counter {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none; }
  
  .mfp-loading.mfp-figure {
    display: none; }
  
  .mfp-hide {
    display: none !important; }
  
  .mfp-preloader {
    color: #cccccc;
    position: absolute;
    top: 50%;
    width: auto;
    text-align: center;
    margin-top: -0.8em;
    left: 8px;
    right: 8px;
    z-index: 1044; }
  
  .mfp-preloader a {
    color: #cccccc; }
  
  .mfp-preloader a:hover {
    color: white; }
  
  .mfp-s-ready .mfp-preloader {
    display: none; }
  
  .mfp-s-error .mfp-content {
    display: none; }
  
  button.mfp-close,
  button.mfp-arrow {
    overflow: visible;
    cursor: pointer;
    background: transparent;
    border: 0;
    -webkit-appearance: none;
    display: block;
    padding: 0;
    z-index: 1046;
    -webkit-box-shadow: none;
    box-shadow: none; }
  
  button::-moz-focus-inner {
    padding: 0;
    border: 0; }
  
  .mfp-close {
    width: 44px;
    height: 44px;
    line-height: 44px;
    position: absolute;
    right: 0;
    top: 0;
    text-decoration: none;
    text-align: center;
    opacity: 0.65;
    padding: 0 0 18px 10px;
    color: white;
    font-style: normal;
    font-size: 28px;
    font-family: Arial, Baskerville, monospace; }
    .mfp-close:hover, .mfp-close:focus {
      opacity: 1; }
    .mfp-close:active {
      top: 1px; }
  
  .mfp-close-btn-in .mfp-close {
    color: #333333; }
  
  .mfp-image-holder .mfp-close,
  .mfp-iframe-holder .mfp-close {
    color: white;
    right: -6px;
    text-align: right;
    padding-right: 6px;
    width: 100%; }
  
  .mfp-counter {
    position: absolute;
    top: 0;
    right: 0;
    color: #cccccc;
    font-size: 12px;
    line-height: 18px; }
  
  .mfp-arrow {
    position: absolute;
    opacity: 0.65;
    margin: 0;
    top: 50%;
    margin-top: -55px;
    padding: 0;
    width: 90px;
    height: 110px;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }
  
  .mfp-arrow:active {
    margin-top: -54px; }
  
  .mfp-arrow:hover,
  .mfp-arrow:focus {
    opacity: 1; }
  
  .mfp-arrow:before, .mfp-arrow:after,
  .mfp-arrow .mfp-b,
  .mfp-arrow .mfp-a {
    content: '';
    display: block;
    width: 0;
    height: 0;
    position: absolute;
    left: 0;
    top: 0;
    margin-top: 35px;
    margin-left: 35px;
    border: medium inset transparent; }
  .mfp-arrow:after,
  .mfp-arrow .mfp-a {
    border-top-width: 13px;
    border-bottom-width: 13px;
    top: 8px; }
  .mfp-arrow:before,
  .mfp-arrow .mfp-b {
    border-top-width: 21px;
    border-bottom-width: 21px; }
  
  .mfp-arrow-left {
    left: 0; }
    .mfp-arrow-left:after,
    .mfp-arrow-left .mfp-a {
      border-right: 17px solid white;
      margin-left: 31px; }
    .mfp-arrow-left:before,
    .mfp-arrow-left .mfp-b {
      margin-left: 25px;
      border-right: 27px solid #3f3f3f; }
  
  .mfp-arrow-right {
    right: 0; }
    .mfp-arrow-right:after,
    .mfp-arrow-right .mfp-a {
      border-left: 17px solid white;
      margin-left: 39px; }
    .mfp-arrow-right:before,
    .mfp-arrow-right .mfp-b {
      border-left: 27px solid #3f3f3f; }
  
  .mfp-iframe-holder {
    padding-top: 40px;
    padding-bottom: 40px; }
  
  .mfp-iframe-holder .mfp-content {
    line-height: 0;
    width: 100%;
    max-width: 900px; }
  
  .mfp-iframe-scaler {
    width: 100%;
    height: 0;
    overflow: hidden;
    padding-top: 56.25%; }
  
  .mfp-iframe-scaler iframe {
    position: absolute;
    display: block;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
    background: black; }
  
  .mfp-iframe-holder .mfp-close {
    top: -40px; }
  
  /* Main image in popup */
  img.mfp-img {
    width: auto;
    max-width: 100%;
    height: auto;
    display: block;
    line-height: 0;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    padding: 40px 0 40px;
    margin: 0 auto; }
  
  /* The shadow behind the image */
  .mfp-figure:after {
    content: '';
    position: absolute;
    left: 0;
    top: 40px;
    bottom: 40px;
    display: block;
    right: 0;
    width: auto;
    height: auto;
    z-index: -1;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
    background: #444444; }
  
  .mfp-figure {
    line-height: 0; }
  
  .mfp-bottom-bar {
    margin-top: -36px;
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    cursor: auto; }
  
  .mfp-title {
    text-align: left;
    line-height: 18px;
    color: #f3f3f3;
    word-wrap: break-word;
    padding-right: 36px; }
  
  .mfp-figure small {
    color: #bdbdbd;
    display: block;
    font-size: 12px;
    line-height: 14px; }
  
  .mfp-image-holder .mfp-content {
    max-width: 100%; }
  
  .mfp-gallery .mfp-image-holder .mfp-figure {
    cursor: pointer; }
  
  @media screen and (max-width: 800px) and (orientation: landscape), screen and (max-height: 300px) {
    /**
     * Remove all paddings around the image on small screen
     */
    .mfp-img-mobile .mfp-image-holder {
      padding-left: 0;
      padding-right: 0; }
  
    .mfp-img-mobile img.mfp-img {
      padding: 0; }
  
    /* The shadow behind the image */
    .mfp-img-mobile .mfp-figure:after {
      top: 0;
      bottom: 0; }
  
    .mfp-img-mobile .mfp-bottom-bar {
      background: rgba(0, 0, 0, 0.6);
      bottom: 0;
      margin: 0;
      top: auto;
      padding: 3px 5px;
      position: fixed;
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box; }
  
    .mfp-img-mobile .mfp-bottom-bar:empty {
      padding: 0; }
  
    .mfp-img-mobile .mfp-counter {
      right: 5px;
      top: 3px; }
  
    .mfp-img-mobile .mfp-close {
      top: 0;
      right: 0;
      width: 35px;
      height: 35px;
      line-height: 35px;
      background: rgba(0, 0, 0, 0.6);
      position: fixed;
      text-align: center;
      padding: 0; }
  
    .mfp-img-mobile .mfp-figure small {
      display: inline;
      margin-left: 5px; } }
  @media all and (max-width: 900px) {
    .mfp-arrow {
      -webkit-transform: scale(0.75);
      transform: scale(0.75); }
  
    .mfp-arrow-left {
      -webkit-transform-origin: 0;
      transform-origin: 0; }
  
    .mfp-arrow-right {
      -webkit-transform-origin: 100%;
      transform-origin: 100%; }
  
    .mfp-container {
      padding-left: 6px;
      padding-right: 6px; } }
  .mfp-ie7 .mfp-img {
    padding: 0; }
  .mfp-ie7 .mfp-bottom-bar {
    width: 600px;
    left: 50%;
    margin-left: -300px;
    margin-top: 5px;
    padding-bottom: 5px; }
  .mfp-ie7 .mfp-container {
    padding: 0; }
  .mfp-ie7 .mfp-content {
    padding-top: 44px; }
  .mfp-ie7 .mfp-close {
    top: 0;
    right: 0;
    padding-top: 0; }
  
  //Magnific overrides
  .mfp-image img{
    background: white;
  }
  .mfp-figure:after {
    background: white;
  }
  
  /*
   * Off Canvas navbar toggle right
   * --------------------------------------------------
   */
  
  @media screen and (max-width: 768px) {
    .row-offcanvas .collapsing {
    -webkit-transition: none 0;
      -moz-transition: none 0;
      transition: none 0;
    }
   .row-offcanvas .navbar {
    position: absolute;
    z-index: 2;
      right:0;
      height:100%;
      width:55px;
      border:0;
      background-color:transparent;
    }
    .row-offcanvas .navbar-toggle {
      margin-right: 5px;
      margin-left: 5px;
    }
    .row-offcanvas {
      position: relative;
    }
    .row-offcanvas-right.active .navbar {
    position: absolute;
    z-index: 2;
      right: -28.4%;
      width:40%;
      background-color:#eee;
      border:0 solid #ddd;
      border-left-width:1px;
    }
    .row-offcanvas-right.active {
      left: -30%;
    }
    .row-offcanvas-right.active .navbar-collapse {
      position: relative;
      width: 100%;
    }
    .row-offcanvas .content {
    /*width:calc(100% - 60px);*/
    }
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">MethodsPaperAnalysis</h1>
<h2 class="author">Matt Cannon</h2>
</div>
<div id="wrap">
<div class="container">
<div class="row row-offcanvas row-offcanvas-right">
<div class="contents col-xs-12 col-md-10">
<h1 id="testing-samples-for-parasites">Testing samples for parasites</h1>
<h2 id="load-libraries">Load libraries</h2>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">library(ggplot2)
library(reshape2)
library(plyr)
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))</code></pre>
</div>
<h2 id="setup">Setup</h2>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">mkdir output
mkdir misc
mkdir output/fastqc
mkdir output/primersRemoved
mkdir output/primersRemoved/paired
mkdir output/primersRemoved/noShort
mkdir output/pandaseqd
mkdir output/pandaseqd/noShort
mkdir output/blastOut
mkdir output/pandaseqd/noShort/unwanted
cp ../firstMiseqTest/misc/unculturedOrgs.gi misc/</code></pre>
</div>
<h2 id="parse-out-raw-fastq-files">Parse out raw fastq files</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;

##############################
# By Matt Cannon
# Date: 05/10/2017
# Last modified: 05/10/2017
# Title: parseFastqBarcodesDualIndex.pl
# Purpose: Parse fastq files to separate files by barcodes
##############################

##############################
# Options
##############################


my $verbose;
my $help;
my $keyFile;
my $R1;
my $R2;
my $I5;
my $I7;
my $outdir = "parsedFastqFiles";
my $errors = 0;

# i = integer, s = string
GetOptions ("verbose"           => \$verbose,
            "help"              => \$help,
            "keyFile=s"         => \$keyFile,
            "R1=s"              => \$R1,
            "R2=s"              => \$R2,
            "I5=s"              => \$I5,
            "I7=s"              => \$I7,
            "outdir=s"          => \$outdir,
        "errors=i"          => \$errors
            )
or pod2usage(0) && exit;

pod2usage(1) && exit if ($help);

##############################
# Global variables
##############################
my %barcodeHash;
my %barcodeCountHash;
my %outputFileHash;
my $counter = 1;
my $foundCounter = 0;
my %linesToPrint;

##############################
# Code
##############################

##############################
### Let the script read in gzipped files
$R1 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
$R2 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
$I5 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
$I7 =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;

##############################
### Make the output folder

if($verbose) {
    print STDERR "\n\nOutput files will be written to $outdir\n";
    print STDERR "Make sure you have deleted any previously parsed files, as this script will simply append the new parse to the old one\n";
}

mkdir $outdir; #output folder

##############################
### Read in key file and create hash of barcodes with output file as value
### This information should be tab delimited, with sample\tRevComplBarcodeI5\tRevComplBarcodeI7
if($verbose) { 
    print STDERR "Reading key file\n";
}
open KEYFILE, $keyFile or die "Could not open sample-barcode key file\nWell, crap\n";
while (my $input = <KEYFILE>){
    chomp $input;
    my ($sampleID, $barcodeI5, $barcodeI7) = split "\t", $input;
    if($errors > 0) {
    my @I5array = ($barcodeI5);
    my @I7array = ($barcodeI7);
    for(my $i = 0; $i < $errors; $i++) {
        @I5array = oneOff(@I5array);
        @I7array = oneOff(@I7array);
    }

    for my $I5current (@I5array) {
        for my $I7current (@I7array) {
        $barcodeHash{$I5current . $I7current} = $sampleID;
        }
    }
    } else {
    $barcodeHash{$barcodeI5 . $barcodeI7} = $sampleID;
    }
}
close KEYFILE;
$barcodeHash{"unknownunknown"} = "unknownBarcodes";

##############################
### Make up a hash of data to print
if($verbose) { 
    print STDERR "Prepping output files\n";
}

for my $barcode (keys %barcodeHash) {
    @{ $linesToPrint{$barcode}{R1} } = ();
    @{ $linesToPrint{$barcode}{R2} } = ();
}
@{ $linesToPrint{unknownunknown}{R1} } = ();
@{ $linesToPrint{unknownunknown}{R2} } = ();

##############################
### Open the fastq files and print out output files
if($verbose) {
    print STDERR "Parsing fastq files\n";
}

open my $I5FILE, $I5 or die "Could not open I5 file\n";
open my $I7FILE, $I7 or die "Could not open I7 file\n";
open my $R1FILE, $R1 or die "Could not open R1 file\n";
open my $R2FILE, $R2 or die "Could not open R2 file\n";

#Go through the I files and pull in the matching R1 and R2 entries
while (my $iFileLine = <$I5FILE>) { 
    my @i5Lines = getThreeLines($I5FILE); #get the next three I5 lines
    unshift(@i5Lines, $iFileLine); # put all the I5 lines together
    chomp @i5Lines;
    my $I5barcode = $i5Lines[1];
    my @i7Lines = getFastq($I7FILE);
    my $I7barcode = $i7Lines[1];
    my @r1Lines = getFastq($R1FILE);
    my @r2Lines = getFastq($R2FILE);
    if(checkHeaders($i5Lines[0], $i7Lines[0], $r1Lines[0], $r2Lines[0]) == 1) { #Check to be sure that I5, I7, R1 and R2 all are the same read
        print STDERR "Your files are not sorted properly, I need the headers for I5, I7, R1 and R2 to be in an identical order\n";
        die; 
    }
    $r1Lines[0] = join(":", $r1Lines[0], $I5barcode, $I7barcode);
    $r2Lines[0] = join(":", $r2Lines[0], $I5barcode, $I7barcode);
    if(exists($barcodeHash{$I5barcode . $I7barcode})) { #write the read out to a file with the sample name if the barcode exists in the input list
        printLines($I5barcode, $I7barcode, "R1", join("\n", @r1Lines));
        printLines($I5barcode, $I7barcode, "R2", join("\n", @r2Lines));
        $barcodeCountHash{$barcodeHash{$I5barcode . $I7barcode}}++;
    $foundCounter++;
    } else { #write the read out to an "unknownBarcode" file if the barcode is missing from the input list
        printLines("unknown", "unknown", "R1", join("\n", @r1Lines));
        printLines("unknown", "unknown", "R2", join("\n", @r2Lines));
        $barcodeCountHash{unknown}++; 
    }
    if($verbose) {
    if($counter % 10000 == 0) {
        print STDERR commify($counter), " fastq entries processed. ", commify($foundCounter), " barcodes matched                             \r";
    }
    $counter++;
    }
}
print STDERR "Printing out final reads                                  \n";
close $I5FILE;
close $I7FILE;
close $R1FILE;
close $R2FILE;

# Print out the last of the lines
for my $barcode (keys %linesToPrint) {
    if(scalar(@{ $linesToPrint{$barcode}{R1} }) > 0) {
    open OUTPUTR1, '>>', $outdir . "/" . $barcodeHash{$barcode} . "R1.fastq";
    open OUTPUTR2, '>>', $outdir . "/" . $barcodeHash{$barcode} . "R2.fastq";
    print OUTPUTR1 join("\n", @{ $linesToPrint{$barcode}{R1} }),"\n";
    print OUTPUTR2 join("\n", @{ $linesToPrint{$barcode}{R2} }),"\n";
    close OUTPUTR1;
    close OUTPUTR2;
    }
}

if($verbose) {
    print STDERR "Printing out summary log file              \n";
}
# Print out summary
open my $barcodeLogFile, '>', $outdir . "/barcodeSummaryLog.txt";
for my $barcode (sort { $barcodeCountHash{$b} <=> $barcodeCountHash{$a} } keys %barcodeCountHash) {
    if(exists($barcodeHash{$barcode})) {
        print $barcodeLogFile $barcode, "\t", $barcodeHash{$barcode}, "\t", $barcodeCountHash{$barcode}, "\n";
    } else {
        print $barcodeLogFile $barcode, "\tUnknownSample\t", $barcodeCountHash{$barcode}, "\n";
    }
    
}
close $barcodeLogFile;

sub oneOff {
    my @bcArray = @_;
    my @newBCArray = @bcArray;
    my @baseArray = ("A", "T", "C", "G");
    for(my $i = 0; $i < scalar(@bcArray); $i++) {
    for(my $j = 0; $j < length($bcArray[$i]); $j++) {
        my @currentBC = split "", $bcArray[$i];
        for my $base (@baseArray) {
        if($base ne $currentBC[$j]) {
            $currentBC[$j] = $base;
            push @newBCArray, join("", @currentBC);
        }
        }
    }
    }
    return @newBCArray;
}

sub getThreeLines {
    my $fh = shift;
    my @storage;
    for(my $i = 0; $i < 3; $i++){
        my $nextLine = <$fh>;
        push(@storage, $nextLine);
    }
    chomp @storage;
    return @storage;
}

sub getFastq {
    my $fh = shift;
    my @storage;
    for(my $i = 0; $i < 4; $i++) {
        my $nextLine = <$fh>;
        push(@storage, $nextLine);
    }
    chomp @storage;
    return @storage;
}

sub checkHeaders {
    my ($header1, $header2, $header3, $header4) = (@_);
    $header1 =~ s/\s.+//;
    $header2 =~ s/\s.+//;
    $header3 =~ s/\s.+//;
    $header4 =~ s/\s.+//;
    if($header1 ne $header2 | $header1 ne $header3 | $header1 ne $header4) {
        return 1;
    } else {
        return 0;
    }
}

sub printLines {
    my ($I5barcode, $I7barcode, $R1or2, $lines) = (@_);
    push @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} }, $lines;
    if(scalar( @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} } ) == 10000) {
    open OUTPUT, '>>', $outdir . "/" . $barcodeHash{$I5barcode . $I7barcode} . $R1or2 . ".fastq";
    print OUTPUT join("\n", @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} }),"\n";
        @{ $linesToPrint{$I5barcode . $I7barcode}{$R1or2} } = ();
    close OUTPUT;
    }
}

sub commify { # function stolen from web
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}


##############################
# POD
##############################

=pod

=head NAME

parseFastqBarcodesDualIndex.pl - generates a consensus for a specified gene in a specified taxa

=head SYNOPSIS

perl parseFastqBarcodesDualIndex.pl [options] --keyFile <keyfile.csv> --I5 <I5.fastq.gz> --I7 <I7.fastq.gz> --R1 <R1.fastq.gz> --R2 <R2.fastq.gz>

=head OPTIONS

This script uses I5 and I7 fastq files to parse out R1 and R2 fastq files. A key file is also provided as input. The output is written to 
"parsedFastqFiles/" unless the user provides another output directory. B<Be careful when using this script. If files with the same name are
in the output directory the data will be appended to the end of those files instead of overwriting them. So if you rerun this script you can 
duplicate your reads accidentaly.> 

Options:

=over 4

=item B<--verbose>

    Provide detailed progress summary.

=item B<--help>

    This stuff.

=item B<--keyFile>

    Required. Tab delimited file with three columns. The first is the sample ID. The next two are the I5 and I7 barcodes for that sample. 

=item B<--R1>

    Required. R1 file. Can be gzipped.

=item B<--R2>

    Required. R2 file. Can be gzipped.

=item B<--I5>

    Required. I5 file. Can be gzipped.

=item B<--I7>

    Required. I7 file. Can be gzipped.

=item B<--outdir> ("parsedFastqFiles")

    Output directory. 

=item B<--errors> (0)

    Number of mismatches allowed within each barcode.

=back

=cut</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash"># run from  ~/SerreDLab-3/raw_reads/2017-09-12_UMB/ folder
perl ~/SerreDLab-3/cannonm3/scripts/fastqTools/parseFastqBarcodesDualIndexTemp.pl -I7  MCHB1_20170908_M01994_IL100092583_NoIndex_L001_R2.fastq.gz -I5  MCHB1_20170908_M01994_IL100092583_NoIndex_L001_R3.fastq.gz -R1  MCHB1_20170908_M01994_IL100092583_NoIndex_L001_R1.fastq.gz -R2  MCHB1_20170908_M01994_IL100092583_NoIndex_L001_R4.fastq.gz --keyFile sampleKey.txt --verbose --errors 0

parallel -j 10 'gzip {}' ::: parsedFastqFiles/*.fastq</code></pre>
</div>
<h2 id="run-pandaseq">Run pandaseq</h2>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">for forward in /home/matthewcannon/SerreDLab-3/raw_reads/2017-09-12_UMB/parsedFastqFiles/[FS]*R1.fastq.gz  
do 
  reverse=${forward%%R1.fastq.gz}R2.fastq.gz 
  base=${forward%%R1.fastq.gz}
  base=${base##*/}
  output=${forward%%R1.fastq.gz}.fastq
  output=${output##*/}

  zcat ${forward} ~/SerreDLab-3/raw_reads/2017-07-07_UMB/parsedFastqFiles/${base}R1.fastq.gz > tempR1.fastq
  zcat ${reverse} ~/SerreDLab-3/raw_reads/2017-07-07_UMB/parsedFastqFiles/${base}R2.fastq.gz > tempR2.fastq
  
  pandaseq -T 30 -F -L 500 -B -f tempR1.fastq -r tempR2.fastq 2> output/pandaseqd/${output}Log.txt | gzip > output/pandaseqd/${output}.gz
done</code></pre>
</div>
<h2 id="cut-primer-sequences-off-of-the-reads-and-put-primer-name-in-fastq-header">Cut primer sequences off of the reads and put primer name in fastq header</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use warnings;
use English;



#this script takes in a list of primers in the format primerName ForwardPrimer ReversePrimer (on each line) and a number denoting how much of the 3' end to use for matching, then it takes in a fastq file and cuts off any primers 
#the program should be run like: perl CutOffSequencFromFastqV1.pl 10 primerlist.txt sampleID-SE[1or2].fastq.gz > output.txt
#the output is a fastq file with the sequence and quality trimmed and the sample ID (from file name) and primer added to the header
#    ## You will want to screen out hits with "noPrimer" in the primer slot of the header afterwards.

my $lengthOfPrimerToMatch = shift; # this is the number of bases on the 3' end of the primer that will be matched

my %primerHash;
my %degeneratehash = ( #hash of arrays - degenerate bases with matching bases
               W =>["A","T"],
               S =>["C","G"],
               M =>["A","C"],
               K =>["G","T"],
               R =>["A","G"],
               Y =>["C","T"],
               B =>["C","G","T"],
               D =>["A","G","T"],
               H =>["A","C","T"],
               V =>["A","C","G"],
               N =>["A","C","G","T"]
               );

## Get the primers and make multiple versions for degenerate bases
my $inputFileName = shift;
open INPUTFILE, "$inputFileName" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE>){
    chomp $input;
    addPrimerToHash($input);
}

sub addPrimerToHash {
    my $input = shift; 
    my ($primerName, $primerF, $primerR) = split " ", $input;
    $primerF = trimPrimer($primerF);
    $primerR = trimPrimer($primerR);
    dealWithDegenerates($primerF,$primerName);
    dealWithDegenerates($primerR,$primerName);
}

sub trimPrimer {
    my $primer = shift;
    if(length($primer)<$lengthOfPrimerToMatch){
    die "You can't trim that much primer!!!\nYour trim length is longer than your primer!!!";
    }
    my $trimmedPrimer = substr($primer,length($primer)-$lengthOfPrimerToMatch,$lengthOfPrimerToMatch); # get the last N bases
    return($trimmedPrimer);
}

sub dealWithDegenerates {
    my $primer = $_[0];
    my $primerName = $_[1];
    if($primer =~ /[WSMKRYBDHVN]/) { #if the primer has any degenerate bases, deconvolute those and add the subsequent primers to the hash
    addDegeneratePrimer($primer,$primerName);
    } else {
    $primerHash{$primer}=$primerName;
    }
}

sub addDegeneratePrimer {
    my $primer = $_[0];
    my $primerName = $_[1];
    my @primerArray = ($primer); #make an array containing the degenerate primer
    my @tempArray = (); #make a temporary array to hold the new versions of the primers
    my $test = 1;
    while($test==1){
    for(my $i=0;$i<scalar(@primerArray);$i++) { # sort through primerArray
        if($primerArray[$i] =~ /[WSMKRYBDHVN]/) { #if 
        push( @tempArray, getNewPrimerVersions($primerArray[$i]) );
        } else {
        push( @tempArray, $primerArray[$i] ); #add normal primer to tempArray
        }
    }
    @primerArray = @tempArray;
    @tempArray = ();
    if(join("",@primerArray) =~ /[WSMKRYBDHVN]/ == 1){
        $test=1;
    } else {
        $test=0;
    }
    }    
    for(@primerArray) {
    $primerHash{$_} = $primerName; #add these sequences to the primerHash
    }    
}

#Go through the primer, and find any degenerate bases
#Then make seperate versions of the primer for each possible sequence and add that to @primerArray
sub getNewPrimerVersions {  
    my $primer = shift; #primer sequence
    my @baseArray = split("", $primer); #split the primer up into individual bases in an array
    my @tempArray=();
    for(my $i=0;$i<scalar(@baseArray);$i++){ #go through each base in the primer
    my $nucleotide = $baseArray[$i];
    if($nucleotide =~ /[WSMKRYBDHVN]/) { #if that base has a degenerate base
        for(@{$degeneratehash{$nucleotide}}) { #go through the possible replacements 
        my @copyArray = @baseArray; # copy this array so we can modify it
        $copyArray[$i] = $_; #then switch out the base in the copy array with a possibility
        push(@tempArray,join("",@copyArray)); #and add the new decoded primer sequence to the end of the @primerArray
        }
    }
    }
    return @tempArray
}



#for my $primerSeq (keys %primerHash) {
#    print STDERR join("\t", $primerHash{$primerSeq}, $primerSeq) . "\n";
#}

close INPUTFILE;



### Now, pull in the fastq 

@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;
my $inputFileName2 = shift;
my $line=1;
my $storage;

open INPUTFILE2, "$inputFileName2" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE2>){
    chomp $input;
    if($line==1) {
    $storage=$input;
    } elsif($line<4) {
    $storage = join("\t",$storage, $input);
    } elsif($line==4) {
    $storage = join("\t",$storage, $input);
    trimSequence($storage);
    $line=0;
    }
    $line++;
}

sub trimSequence {
    my $fastq = shift;
    my ($header, $sequence, $header2,$quality) = split "\t", $fastq;
    my @trimmedSeqPrimerQual = searchSequenceForPrimer($sequence,$quality);
    $inputFileName2 =~ s/.+DS/DS/;
    $inputFileName2 =~ s/_SE[12].fastq.gz//;
    $inputFileName2 =~ s/.+\///;
    $inputFileName2 =~ s/R[12].fastq.gz//;
    my $newHeader = $header;
    $newHeader = $newHeader . "|" . $trimmedSeqPrimerQual[1] . "|" . $inputFileName2;
    my $newfastq = join("\n", $newHeader,$trimmedSeqPrimerQual[0],"+",$trimmedSeqPrimerQual[2]);
    print $newfastq, "\n";
}

sub searchSequenceForPrimer {
    my $sequence = shift;
    my $qual = shift;
    my $trimSeq;
    my $trimQual;
    my $primerHit="noPrimer";
    my $flag = 0;
    my @returnValue; 
    my $firstFifty = substr($sequence,0,50);
    my %matchCountHash;
    my %matchSeqHash;
    for my $primerSeq (keys %primerHash) {
    my $reverse = revComp($primerSeq);
    if($firstFifty =~ /$primerSeq/) {
        $flag = 1;
        $matchCountHash{$primerHash{$primerSeq}}+=2; #count the number of times each primer is seen and add one extra to the forward primer matches to break ties if one primer is found from two different primer pairs
        $matchSeqHash{$primerHash{$primerSeq}}{forward}=$primerSeq; #store the primer sequence for later use
    } elsif($sequence =~ /$reverse/) {
        #$matchCountHash{$primerHash{$primerSeq}}++; # make the forward read the only one that matters....
        $matchSeqHash{$primerHash{$primerSeq}}{reverse}=$reverse;
    } 
    }
    if($flag==1){
        my @keys = sort { $matchCountHash{$b} <=> $matchCountHash{$a} } keys %matchCountHash;
    $primerHit = $keys[0];
        my $forward = $matchSeqHash{$primerHit}{forward};  #forward
    $sequence =~ /$forward/g;
        $trimSeq = substr($sequence, pos($sequence), length($sequence)- pos($sequence)  );
        $trimQual = substr($qual, pos($sequence), length($qual)- pos($sequence)  );
        $sequence = $trimSeq;
        $qual = $trimQual;
        if(exists($matchSeqHash{$keys[0]}{reverse}) ) { #reverse
            if($sequence =~ /$matchSeqHash{$keys[0]}{reverse}/){ 
        my $reverse = $matchSeqHash{$keys[0]}{reverse};
        $sequence =~ /$reverse/g;
        $trimSeq = substr( $sequence, 0, pos($sequence)- length($reverse) );
        $trimQual = substr( $qual, 0, pos($sequence)- length($reverse) );
        $sequence = $trimSeq;
        $qual = $trimQual;
        } else { # if the reverse primer was found in the full length sequence, but not the trimmed, it means that the primers overlap, so get rid of the read
        $sequence = "A";
        $qual = "X";
        }
    }
    @returnValue = ($sequence,$primerHit,$qual);
    } else {
    @returnValue = ("primerNotFound","noPrimer",$qual);
    }
    return @returnValue;
}


sub revComp{
    my $seq = shift;
    $seq =~ tr/ACGTacgt/TGCAtgca/;
    reverse($seq);
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 20 'perl ~/SerreDLab-2/cannonm3/scripts/CutOffSequenceFromFastqV2.pl 15 misc/primerKey.txt {} | gzip > output/primersRemoved/{/}' ::: output/pandaseqd/*fastq.gz</code></pre>
</div>
<h2 id="filter-out-the-short-sequences">Filter out the short sequences</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!usr/bin/perl
use strict;
use warnings;
use English;

#this script takes in a fastq file and removes any entries where the sequnce length is less than the given cutoff 
##usage should be perl filterShortFastq.pl 50 file_SE1.fastq.gz 


my $line =1;
my $storage;

my $minLength = shift;

while (my $input = <>){
    chomp $input;
    if($line==1) {
        $storage=$input;
    } elsif($line<4) {
        $storage = join("\n",$storage, $input);
    } elsif($line==4) {
        $storage = join("\n",$storage, $input);
        printGoodLines($storage);
        $line=0;
    }
    $line++;
}


sub printGoodLines {
    my $fastq = shift;
    my ($header, $sequence, $header2,$quality) = split "\n", $fastq;
    if(length($sequence)>=$minLength) {
        print $fastq, "\n";
    }
}

exit;</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">parallel -j 20 'zcat {} | perl ~/SerreDLab-2/cannonm3/scripts/filterShortFastq.pl 75 | gzip > output/primersRemoved/noShort/{/}' ::: output/primersRemoved/*fastq.gz</code></pre>
</div>
<h2 id="put-all-the-fasta-files-together">Put all the fasta files together</h2>
Add the sample name to the file and combine.
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">zcat output/primersRemoved/noShort/*.fastq.gz | zgrep -A 1 @HWI | grep -v "^--" | perl -pe 's/\@HWI/>HWI/' > output/blastOut/merged_products.fa</code></pre>
</div>
<h2 id="get-only-unique-sequences">Get only unique sequences</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use warnings;

local $/ = "\n>"; #change the input delimiter to > so the script pulls in the whole fasta entry

#This script takes in fasta files and keeps one unique sequence 
#Outputs files identical to Mothur's unique.seqs: .names and .unique.fasta

my %storageHash;
my %headerStorage;
my $counter=0;
my $uniqueCounter=0;

my $FileName = shift;

if($FileName eq "--help") { #ha!
    die "What, do you need me to hold your hand?!?!?!?!\nJust give me a damn fasta file!\n";
} elsif($FileName eq "--version") {
    die "It's rude to ask someone's age.\n"
}

open FILE, "$FileName" or die "Could not open $FileName\nWell, crap.....\n";

while(my $file = <FILE>){
    $counter++;
    chomp $file;
    my ($header,$seq)=split "\n", $file,2;
    $header =~ s/^>//;
    die "Duplicate fasta headers detected\n" if exists($headerStorage{$header});
    $headerStorage{$header}=1;
    $seq =~ s/\n//g; #get rid of extra newlines in sequence
    if( !exists($storageHash{$seq}) & !exists($storageHash{revcomp($seq)}) ) { 
    $storageHash{$seq}=$header;
    $uniqueCounter++;
    } elsif( exists($storageHash{$seq}) ) {
    $storageHash{$seq}=join("\t",$storageHash{$seq},$header);
    } elsif( exists( $storageHash{revcomp($seq)} ) ) {
    $storageHash{$seq}=join("\t",$storageHash{revcomp($seq)},$header);
    }
    #print STDERR "\e[JSequences analyzed:\t",commify($counter),"\tUnique Sequences:\t",commify($uniqueCounter),"\r";
}

$FileName =~ s/\.fasta//;
$FileName =~ s/\.fa//;
open my $fastaOutputFile, ">", join(".",$FileName,"unique.fasta");
open my $namesOutputFile, ">", join(".",$FileName,"names");

#print STDERR "Printing output\n";

for my $sequence (keys %storageHash) {
    my $firstHeader = $storageHash{$sequence};
    $firstHeader =~ s/\t.+//;
    print $fastaOutputFile ">",$firstHeader,"\n",$sequence,"\n";
    print $namesOutputFile $firstHeader,"\t", join(",", split("\t", $storageHash{$sequence}) ),"\n";
}

#print STDERR "Done!\nSequences analyzed:\t",commify($counter),"\tUnique Sequences:\t",commify($uniqueCounter),"\n";

sub revcomp {
    my $seq = shift;
    $seq =~ tr/ATGCatgc/TACGtacg/;
    my $seqOut = reverse($seq);
    return $seqOut;
}

sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">#gunzip -f output/blastOut/merged_products.fa.gz
perl ~/SerreDLab-2/cannonm3/scripts/mattsMothur.pl output/blastOut/merged_products.fa
 
gawk -F"\t" '{print $2}' output/blastOut/merged_products.names > temp  
perl -pe s/","/"\t"/g temp > output/blastOut/merged_products.names
gzip -f output/blastOut/merged_products.names
gzip -f output/blastOut/merged_products.unique.fasta
gzip -f output/blastOut/merged_products.fa</code></pre>
</div>
<h2 id="filter-out-any-sequences-seen-less-than-5-times">Filter out any sequences seen less than 5 times</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!usr/bin/perl
use strict;
use warnings;
use English;

# This script takes the output from mothur and screens out any reads with less than X total occurences. 
# syntax should be perl filterMothurByCount.pl 10 file.fa.gz file.names.gz > output.fa

my $cutoff = shift;
my %namesHash;

@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;

my $inputFileName = shift;
open INPUTFILE, "$inputFileName" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE>){
    chomp $input;
    my @names = split "\t", $input;
    if(scalar(@names) > $cutoff) {
        $namesHash{$names[0]}=$input;
    }
}
close INPUTFILE;


my $inputFile2Name = shift;

##prep the files for writing out
my $r2fileName = $inputFile2Name;
$r2fileName =~ s/.+\///; #get rid of path and other crap
$r2fileName =~ s/unique.fa.gz\|//;
$r2fileName =~ s/unique.fasta.gz\|//;
$r2fileName =~ s/unique.fna.gz\|//;
my $r1fileName = $r2fileName;
$r2fileName = $r2fileName . "unique.filtered.fa";
$r1fileName = $r1fileName . "filtered.names";
open my $r1File, '>', "output/$r1fileName";
open my $r2File, '>', "output/$r2fileName";

local $/ = "\n>"; #change the input delimiter to \n> so the script pulls in the whole fasta entry

open INPUTFILE2, "$inputFile2Name" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE2>){
    chomp $input;
    my ($header,$sequence) = split "\n", $input;
    if(exists($namesHash{$header})) {
        print $r2File ">".$input,"\n";
    print $r1File $namesHash{$header}, "\n";
    }
}

close INPUTFILE2;</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">perl ~/SerreDLab-2/cannonm3/scripts/filterMothurByCount.pl 5 output/blastOut/merged_products.names.gz output/blastOut/merged_products.unique.fasta.gz

mv output/merged_products.* output/blastOut/
#writes out two files: output/blastOut/merged_products.filtered.names  output/blastOut/merged_products.unique.filtered.fa</code></pre>
</div>
<h1 id="blast-alignment">## Blast alignment ##</h1>
<p>The filter environmental samples option on online blast using the Entrez query <code>all [filter] NOT(environmental samples[organism] OR metagenomes[orgn] OR txid32644[orgn])</code> to remove uncultured samples. In order to reproduce this I downloaded all the gi’s for the query <code>all [filter] NOT(environmental samples[organism] OR metagenomes[orgn] OR txid32644[orgn])</code> using a browser and put them in <code>data/uncultured_samples.gi.gz</code>. The gi’s are then filtered out using the -negative_gilist option.</p>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">blastn -task blastn -negative_gilist ../thirdMiseqBrandyMosq/misc/unculturedOrgs.gi -db /export/databases/blast/nt -query output/blastOut/merged_products.unique.filtered.fa -outfmt 7 -num_threads 40 | gzip > output/blastOut/merged_products-blast.tab.gz</code></pre>
</div>
<h2 id="parse-out-blast-results-using-the-.names-file">Parse out blast results using the .names file</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use warnings;
use strict;
use English;

##format should be perl parseBlastWithNameFile.pl file.names file.blast.tab.gz > outputfile.txt

my %readNameHash;
my %readLengthHash;
my $newRead;
my $maxBitscore;

@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;

my $inputFileName = shift;
open INPUTFILE, "$inputFileName" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE>){
    chomp $input;
    makeNameHash($input);
}
close INPUTFILE;

$inputFileName = shift;
open INPUTFILE, "$inputFileName" or die "$OS_ERROR Could not open first input\nWell, crap\n";
local $/ = "\n>"; #change the input delimiter to > so the script pulls in the whole fasta entry
while (my $input = <INPUTFILE>){
    chomp $input;
    my ($readName, $sequence) = split "\n", $input;
    $readName =~ s/>//;
    $readName =~ s/:\|.+/:/; # cut off sample info
    $readLengthHash{$readName} = length($sequence);
}
close INPUTFILE;

local $/ = "\n";
print "#primerSample\tcount\tgi\tblastedReadName\tidentity\talignmentlength\tmismatches\tgapopens\tqstart\tqend\tsstart\tsend\tevalue\tbitscore","\n"; #header

my $inputFile2Name = shift;
open INPUTFILE2, "$inputFile2Name" or die "$OS_ERROR Could not open second input\nWell, crap\n";
while (my $input = <INPUTFILE2>){
    chomp $input;
    goThroughBlast($input);
}
close INPUTFILE2;

sub makeNameHash {
    my ($firstRead, @junk) = split "\t", $_[0];
    countReadsPerLine($firstRead, $_[0]);
}

sub countReadsPerLine {
    my $firstRead = $_[0];
    $firstRead =~ s/:\|.+/:/;
    my $readNames = $_[1];
    my @readNameArray = split "\t", $readNames;
    for(@readNameArray) {
        s/^.+:\|//;
    } 
    for(my $i = 0; $i < @readNameArray; $i++){
        $readNameHash{$firstRead}{$readNameArray[$i]}++;
    }
}

sub goThroughBlast {
    if($_[0] =~ /^\#/){
        $newRead = 1;
    } else {
        processBlast($_[0]);
    }
}

sub processBlast {
    if($newRead == 1) {
        processFirstRead($_[0]);
    } else {
        processOtherReads($_[0]);
    }
}

sub processFirstRead {
#    my ($queryid, $subjectid, $subjectGi, $taxids, $alignmentlength, $identity, $evalue, $bitscore, $sscinames) = split "\t", $_[0];
    my ($queryid, $subjectid, $identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore) = split "\t", $_[0];
    $maxBitscore = $bitscore;
    $queryid =~ s/:\|.+/:/;
#    print STDERR $queryid, "\t\t\t";
    $subjectid =~ s/gi\|//;
    $subjectid =~ s/\|.+//;
    $identity = ((($qend - $qstart +1) - $mismatches - $gapopens)/ $readLengthHash{$queryid})*100;
    printHit($queryid,$subjectid,join("\t",$identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore)); 
#    printHit($queryid, $subjectid, join("\t", $identity, $alignmentlength, $evalue, $bitscore, $subjectGi, $sscinames)); 
    $newRead = 0;
}

sub processOtherReads {
#    my ($queryid, $subjectid, $subjectGi, $taxids, $alignmentlength, $identity, $evalue, $bitscore, $sscinames) = split "\t", $_[0];
    my ($queryid, $subjectid, $identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore) = split "\t", $_[0];
    if($bitscore == $maxBitscore) {
    $queryid =~ s/:\|.+/:/;
    $subjectid =~ s/gi\|//;
    $subjectid =~ s/\|.+//;
    $identity = ((($qend - $qstart +1) - $mismatches - $gapopens)/ $readLengthHash{$queryid})*100;
    printHit($queryid,$subjectid,join("\t",$identity, $alignmentlength, $mismatches, $gapopens, $qstart, $qend, $sstart, $send, $evalue, $bitscore)); 
#    printHit($queryid, $subjectid, join("\t", $identity, $alignmentlength, $evalue, $bitscore, $subjectGi, $sscinames));
    }
}

sub printHit {
    for my $primerSample (keys %{$readNameHash{$_[0]}}) {
        print join("\t",$primerSample, $readNameHash{$_[0]}{$primerSample},$_[1],$_[0],$_[2]) . "\n";
    }
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">perl ~/SerreDLab-2/cannonm3/scripts/parseBlastWithNameFileSummaryStatsV6.pl output/blastOut/merged_products.filtered.names output/blastOut/merged_products.unique.filtered.fa output/blastOut/merged_products-blast.tab.gz | gzip > output/blastOut/blastGICountsStats.txt.gz 
         
zcat output/blastOut/blastGICountsStats.txt.gz | cut -f 3 | sort | uniq > output/blastOut/gis #make up list of unique gis</code></pre>
</div>
<h2 id="get-the-gi-taxonomy-information-using-jims-primertree-package">Get the GI taxonomy information using Jim’s primertree package</h2>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">library(primerTree)
gis <- read.delim("output/blastOut/gis", header = F)
gis <- subset(gis, V1 != "gi")

taxa <- get_taxonomy(gis$V1)

df <- data.frame(matrix(nrow = nrow(taxa), ncol = 0))
df$gi <- taxa$gi
df$species <- taxa$species
df$kingdom <- taxa$kingdom
df$phylum <- taxa$phylum
df$class <- taxa$class
df$order <- taxa$order
df$family <- taxa$family

write.table(df, file = "output/blastOut/blastTaxaRaw.txt", quote = F, sep = "\t", col.names = T, row.names = F)</code></pre>
</div>
<h2 id="keep-only-the-first-two-words-in-the-species-names-to-get-rid-of-subspecies-labels">Keep only the first two words in the species names to get rid of subspecies labels</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!usr/bin/perl
use strict;
use warnings;
use English;
 
#this script
##usage should be perl

 
while (<>){
    chomp;
    my @columns = split "\t";
    my $species = $columns[1];
    my @speciesArray = split(" ", $species);
    if(scalar(@speciesArray)> 2) {
    $columns[1] = join(" ", $speciesArray[0], $speciesArray[1]);
    }
    print join("\t", @columns),"\n";
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash">perl ~/SerreDLab-2/cannonm3/scripts/fixSpeciesNameCuyahoga.pl output/blastOut/blastTaxaRaw.txt > output/blastOut/blastTaxaRawSpeciesFixed.txt</code></pre>
</div>
<h2 id="combine-the-gi-read-count-data-with-taxa-information-but-include-full-taxonomy">Combine the GI read count data with taxa information, but include full taxonomy</h2>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/user/bin/perl
use strict;
use warnings;
use English;

###this script takes files and combines them by the first X tab separated columns.
###the first file should be the smaller of the two, or the file with single combination of the first X columns
###Assumes that the combination of the first X columns for each row are unique for the first file.
###usage is: perl combineFilesByFirstXColumns.pl 3 file.txt file2.txt > output.txt

my %methHash;

my %rows;
my $fileNumber = 1;
my @fileArray;
my $ncol=shift;
my $totalNcol;

@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;
my @files = @ARGV;

my $InputFile = shift;
open INPUT, "$InputFile" or die "$OS_ERROR Could not open $InputFile\nWell, crap\n";
while (my $input=<INPUT>) {
    chomp $input;
    my @columns = split("\t", $input);
    $totalNcol=scalar(@columns);
    my $reference = join("\t",@columns[0..($ncol-1)]);
    $rows{$reference}=join("\t",@columns[$ncol..(scalar(@columns)-1)]);
}
close INPUT;

$InputFile = shift;
open INPUT, "$InputFile" or die "$OS_ERROR Could not open $InputFile\nWell, crap\n";
while (my $input=<INPUT>) {
    chomp $input;
    my @columns = split("\t",$input);
    $totalNcol=scalar(@columns);
    my $reference = join("\t",@columns[0..($ncol-1)]);
    if(exists($rows{$reference})){
    print join("\t",$input,$rows{$reference})."\n";
    } #else {
#   print "\tNA" x ($totalNcol-$ncol);
#    }
}</code></pre>
</div>
<div class="row">

</div>
<div class="row">
<button class="source perl toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> perl source
</button>
<pre style=""><code class="source perl">#!/usr/bin/perl
use strict;
use English;
use warnings;

# This script takes in a list of columns (WITH NO SPACES) and a file, and keeps one of each occurence of the combination of the value of those columns. It always keeps the first occurence. 
# Syntax should be perl uniqueFileByColumnsV1.pl 1,3,5-10 fileIn.txt > fileOut.txt
# Note that the list of columns is separated by columns, and can include ranges if they are separated by a "-".

my %columnsHash;
my $cutcolumns = shift;
my @selectionColumns = split ",", $cutcolumns;

my @tempArray;
for(my $i=0;$i<@selectionColumns;$i++) {
    if($selectionColumns[$i] =~ /-/){
        my ($start,$stop) = split "-", $selectionColumns[$i];
        for(my $j=$start;$j<=$stop;$j++) {
            push(@tempArray,$j);
        }
    } else {
        push(@tempArray,$selectionColumns[$i]); 
    }
    
}
@selectionColumns=@tempArray;


@ARGV = map { s/(.*\.gz)\s*$/gzip -dc < $1|/;$_ } @ARGV;

my $inputFileName2 = shift;

open INPUTFILE2, "$inputFileName2" or die "$OS_ERROR Could not open first input\nWell, crap\n";
while (my $input = <INPUTFILE2>){
    chomp $input;
    my $hashKey="";
    my @columns = split "\t", $input;
    for(@selectionColumns){
        $hashKey = join("",$hashKey,$columns[$_-1]);
    }
    if(!exists($columnsHash{$hashKey}) ) {
        print $input, "\n";
        $columnsHash{$hashKey}=1;
    }
}</code></pre>
</div>
<div class="row">
<button class="source bash toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> bash source
</button>
<pre style=""><code class="source bash"># move gi to first column  14 cols
zcat output/blastOut/blastGICountsStats.txt.gz | gawk -F"\t" 'BEGIN {OFS = "\t"} {print $3,$1,$2,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14}' > temp

###########################   Truncated Species Name
#combine the prior two files by gi number
perl ~/SerreDLab-2/cannonm3/scripts/combineFilesByFirstXColumnsOrdered.pl 1 output/blastOut/blastTaxaRawSpeciesFixed.txt temp | cut -f 2- > output/blastOut/blastStatsWithTaxaOutputRedundantSpecies.txt 

# keep only one hit per species

###  Check the four numbers
perl ~/SerreDLab-2/cannonm3/scripts/uniqueFileByColumnsV1.pl 1,2,3,4,14 output/blastOut/blastStatsWithTaxaOutputRedundantSpecies.txt > output/blastOut/blastStatsWithTaxaOutputUniqueSpecies.txt

# concatenate duplicate hits
perl ~/SerreDLab-2/cannonm3/scripts/concatenateRepeatReadHitsForBlastV2.pl output/blastOut/blastStatsWithTaxaOutputUniqueSpecies.txt > output/blastOut/blastStatsWithTaxaOutputUniqueSpeciesConcatenated.txt

############################ Normal Species Name
#combine the prior two files by gi number
perl ~/SerreDLab-2/cannonm3/scripts/combineFilesByFirstXColumnsOrdered.pl 1 output/blastOut/blastTaxaRaw.txt temp | cut -f 2- | perl -pe 's/.+?:\|//' > output/blastOut/blastStatsWithTaxaOutputRedundantSpeciesFullName.txt 

# keep only one hit per species



###  Check the four numbers
perl ~/SerreDLab-2/cannonm3/scripts/uniqueFileByColumnsV1.pl 1,2,3,4,14 output/blastOut/blastStatsWithTaxaOutputRedundantSpeciesFullName.txt > output/blastOut/blastStatsWithTaxaOutputUniqueSpeciesFullName.txt

# concatenate duplicate hits
perl ~/SerreDLab-2/cannonm3/scripts/concatenateRepeatReadHitsForBlastV2.pl output/blastOut/blastStatsWithTaxaOutputUniqueSpeciesFullName.txt > output/blastOut/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenated.txt


#keep only those hits with greater than 90% identity
#gawk -F"\t" 'BEGIN {OFS = "\t"} $5>=90 {print $_}' ~/cannonm3/tempdir/blastStatsWithTaxaOutputUniqueSpecies.txt > ~/cannonm3/tempdir/blastStatsWithTaxaOutputUniqueSpecies90PercentIdentity.txt 


cat output/blastOut/merged_products.unique.filtered.fa | perl ~/SerreDLab-2/cannonm3/scripts/fastaSeqLength.pl | perl -pe 's/M.+:.{1,2}\|//g' | perl -pe 's/.DS.+\|//' | gzip  > output/blastOut/merged_products.unique.filtered.fastaLengths.txt.gz
</code></pre>
</div>
<h2 id="summarize-blast-table">Summarize blast table</h2>
<div class="row">
<button class="source R toggle btn btn-xs btn-primary">
<span class="glyphicon glyphicon-chevron-down"></span> R source
</button>
<pre style=""><code class="source r">dataDf <- read.delim("output/blastOut/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenated.txt", header = T)

dataDf$Sample <- gsub("\\|$", "", dataDf$X.primerSample)
dataDf$Sample <- gsub(".+\\|", "", dataDf$Sample)

dataDf$Primer <- gsub("\\|.+", "", dataDf$X.primerSample)

dataDf$identity <- gsub("\\/.+", "", dataDf$identity)

dataDf$alignmentlength <- gsub("\\/.+", "", dataDf$alignmentlength)

wantedCols <- c("Primer", "Sample", "count", "identity", "alignmentlength", "species", "kingdom", "phylum", "class", "order", "family")

dataDf <- dataDf[, colnames(dataDf) %in% wantedCols]

summaryDf <- ddply(dataDf, .(Primer, Sample, species, kingdom, phylum, class, order, family), summarize, count = sum(count), maxIdent = max(as.numeric(identity)), maxAlignLen = max(as.numeric(alignmentlength)))

write.table(summaryDf, file = "output/blastOut/blastStatsWithTaxaOutputUniqueSpeciesFullNameConcatenatedSummary.txt", quote = F, sep = "\t", col.names = T, row.names = F)</code></pre>
</div>
</div>
</div>
<div class="navbar navbar-fixed-bottom navbar-inverse">
<div class="container">
<div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
<span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
</button>
</div>
<div id="bottom-navbar" class="navbar-collapse collapse navbar-responsive-collapse">
<ul class="nav navbar-nav navbar-right">
<li class="nav">
<p class="navbar-text">
Toggle
</p>
</li>
<li class="dropup">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">
Languages
</li>
<li class="active">
<a href="#" class="toggle-global source R" type="source.R">R</a>
</li>
<li class="active">
<a href="#" class="toggle-global source bash" type="source.bash">bash</a>
</li>
<li class="active">
<a href="#" class="toggle-global source perl" type="source.perl">perl</a>
</li>
<li>
<a href="#" type="all-source" class="toggle-global">All</a>
</li>
</ul>
</li>
<li class="active">
<a href="#" type="figure" class="toggle-global">Figures</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="push">

</div>
<div id="footer">
<div class="container">
<p class="text-muted" id="credit">
Styled with <a href="https://github.com/jimhester/knitrBootstrap">knitrBootstrap</a>
</p>
</div>
</div>
<link rel="stylesheet" id="theme" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" media="screen"></link><link rel="stylesheet" id="highlight" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/default.min.css" media="screen"></link>
</div>
</body>
</html>
